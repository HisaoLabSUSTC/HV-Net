/*
	C++ implementation of hypervolume approximation methods in polar coordinate system
	
	This program is based on our paper[1]. Please refer to it for more details.
	Following are function list:
	
	1. "HV_[method]": approximate hypervolume;
	2. "HC_[method]": approximate hypervolume contribution;
	3. "Ihk_[method]": approximate the I^h_k indicator proposed in HypE[2]. It requires
					an additional input the hypervolume parameter k;
	
	where [method] is one of following methods:
	1. Polar: hypervolume approximation methods in polar coordinate system. 
	     - Input: population size $n$, objective number $m$, sample number $w$, 
				point set (an n-by-m double array), and reference point (an m-dim double array);
		 - Output: approximated volumes.
	2. Direction: hypervolume approximation methods in direction space. 		
	     - Input: population size $n$, objective number $m$, sample number $w$, 
				point set (an n-by-m double array), reference point (an m-dim double array),
				sampling points on unit sphere in R^m_+ (an w-by-m double array, it can 
				be generated by Hua_direction.m or normal_direction.m in MATLAB folder),
				and the area of the unit sphere in R^m_+ (see HyperVol.m in folder);
		 - Output: approximated volumes.
		 	
	Editor: Jingda Deng
	Email: jingddeng2-c@my.cityu.edu.hk
	Latest Update: Feb, 2019

	[1] J. Deng, Q. Zhang, “Approximating Hypervolume and Hypervolume Contributions Using Polar Coordinate,”
	IEEE Transactions on Evolutionary Computation (accepted)
	[2] J. Bader and E. Zitzler, “HypE: An algorithm for fast hypervolume-based many-objective optimization,”
	Evolutionary computation, vol. 19, no. 1, pp. 45–76, 2011.

*/

#include <math.h>
#include <functional>
#include <algorithm>
#include <numeric>

#define PI  3.1415926535897932384626433832795

template <typename Container>
struct compare_indirect_index_descend
  {
  const Container& container;
  compare_indirect_index_descend( const Container& container ): container( container ) { }
  bool operator () ( size_t lindex, size_t rindex ) const
    {
    return container[ lindex ] > container[ rindex ];
    }
  };
  
void Index_Sort(double *x, int *idx, int m)
{	
	std::iota(idx, idx+m, 0);
	std::sort( idx, idx+m, compare_indirect_index_descend <decltype(x)> ( x ) );
}

double Jaccobi(double* angle, int m)
{
	double p = 1;
	for(int i=0; i<m; i++)
	{
		p = p*pow(sin(angle[i]), m-i-1);
	}
	return p;
}

void ConstructLattice(int m, int w, double **weights, double *jacobians)
{
	// number-theoretic points
	double eps = 1e-5;
	int p = (m-1)*2+1;		// the dimension of angles is 1 smaller than m
	bool flag = true;
	while(flag)
	{
		flag = false;
		for(int i=3; i<=floor(sqrt(p)); i++)
		{
			if(p%i==0)
			{
				flag = true;
				break;
			}
		}
		if(flag)
			p = p+2;
	}
	int *a = new int[m-1];	// the dimension of angles is 1 smaller than m
	a[0] = 1;
	for(int i=1; i<m-1; i++)
	{
		double temp = 2*cos(2*PI*i/(double)p);
		a[i] = int(w*(fabs(temp) - floor(fabs(temp)))+0.5);
	}

	// lattice points and jacobians
	double **angles = new double*[w];
	for(int i=0; i<w; i++)
	{
		angles[i] = new double[m-1];
		for(int j=0; j<m-1; j++)
		{
			double temp = (i+1)*a[j]/(double)w;
			angles[i][j] = temp - floor(temp);
			if(angles[i][j]<eps)
				angles[i][j] = angles[i][j]+eps;
			if(angles[i][j]>1-eps)
				angles[i][j] = angles[i][j]-eps;
			angles[i][j] = angles[i][j]*PI/2.0;
		}
	}

	for(int i=0; i<w; i++)
	{
		jacobians[i] = Jaccobi(angles[i], m-1);
	}

	// construct weights
	for(int i=0; i<w; i++)
	{
		double sum = 0.;
		double sum2 = 0.;
		weights[i] = new double[m];
		for(int j=0; j<m; j++)
		{
			weights[i][j] = 1;
			for(int k=0; k<m-j-1; k++)
				weights[i][j] = weights[i][j]*sin(angles[i][k]);
			if(j>0)
				weights[i][j] = weights[i][j]*cos(angles[i][m-j-1]);
			weights[i][j] = 1.0/weights[i][j];
		}
	}
	
	for(int i=0; i<w; i++)
	{
		delete[] angles[i];		
	}
	delete[] angles;
	delete[] a;
}

double HV_Polar_Opt(int popsize, int dim, int sample, double **points, double *reference)
{
	int m = dim, n = popsize, w = sample;
	double hv = 0., Length;
	
	double *jacobians = new double[w];
	double **weights = new double*[w];
	for(int i=0; i<w; i++)
	{
		weights[i] = new double[m];
	}
	ConstructLattice(m, w, weights, jacobians);
		
	double ming, v;
	
	for(int i=0; i<w; i++)
	{
		Length = 0.;
		for(int j=0; j<n; j++)
		{
			ming = 1e30;	
			for(int k=0; k<m; k++)
			{
				v = -weights[i][k]*(points[j][k] - reference[k]);
				if(v<Length)
				{
					ming = 0;
					break; // this is a check for early break, same in the following HV_Direction_Opt function
				}
				else
				{
					if(v<ming)
						ming = v;
				}
			}
			if(ming>Length)
				Length = ming;
		}
		Length = pow(Length, m)*jacobians[i];
		hv += Length;
	}
	hv = hv/m/w*pow(PI/2, m-1);
	
	for(int i=0; i<w; i++)
	{
		delete[] weights[i];
	}
	delete[] weights;
	delete[] jacobians;
	
	return hv;
}

double HV_Direction_Opt(int popsize, int dim, int sample, double **points, double *reference, double **samples, double sphere)
{	
	int m = dim, n = popsize, w = sample;
	double hv = 0., ming, v, Length;
	
	for(int i=0; i<w; i++)
	{
		Length = 0.;
		for(int j=0; j<n; j++)
		{
			ming = 1e30;	
			for(int k=0; k<m; k++)
			{
				v = -samples[i][k]*(points[j][k] - reference[k]);
				if(v<Length)
				{
					ming = 0;
					break; 
				}
				else
				{
					if(v<ming)
						ming = v;
				}
			}
			if(ming>Length)
				Length = ming;
		}
		hv += pow(Length, m);
	}
	hv = hv/m/w*sphere;
	return hv;
}

double *HC_Polar(int popsize, int dim, int sample, double **points, double *reference)
{
	int m = dim, n = popsize, w = sample, ID;
	double *hv = new double [n];
	for(int i=0; i<n; i++)
		hv[i] = 0;
	double Length, Length2;
	
	double *jacobians = new double[w];
	double **weights = new double*[w];
	for(int i=0; i<w; i++)
	{
		weights[i] = new double[m];
	}
	ConstructLattice(m, w, weights, jacobians);
		
	double ming, v;
	for(int i=0; i<w; i++)
	{
		Length = 0.;
		Length2 = 0.;
		ID = 0;
		for(int j=0; j<n; j++)
		{
			ming = 1e30;	
			for(int k=0; k<m; k++)
			{
				v = -weights[i][k]*(points[j][k] - reference[k]);
				if(v<ming)
					ming = v;
			}
			if(ming>Length)
			{
				ID = j;
				Length2 = Length;
				Length = ming;
			}
			else
			{
				if(ming>Length2)
					Length2 = ming;
			}
		}
		hv[ID] += (pow(Length, m) - pow(Length2, m))*jacobians[i];
	}
	for(int i=0; i<n; i++)
		hv[i] = hv[i]/m/w*pow(PI/2, m-1);
	
	for(int i=0; i<w; i++)
	{
		delete[] weights[i];
	}
	delete[] weights;
	delete[] jacobians;
	
	return hv;
}

double *HC_Direction(int popsize, int dim, int sample, double **points, double *reference, double **samples, double sphere)
{
	int m = dim, n = popsize, w = sample, ID;
	double *hv = new double [n];
	for(int i=0; i<n; i++)
		hv[i] = 0;
	double Length, Length2;
	
	double ming, v;
	
	for(int i=0; i<w; i++)
	{
		Length = 0.;
		for(int j=0; j<n; j++)
		{
			ming = 1e30;	
			for(int k=0; k<m; k++)
			{
				v = -samples[i][k]*(points[j][k] - reference[k]);
				if(v<ming)
					ming = v;
			}
			if(ming>Length)
			{
				ID = j;
				Length2 = Length;
				Length = ming;
			}
			else
			{
				if(ming>Length2)
					Length2 = ming;
			}
		}
		hv[ID] += pow(Length, m) - pow(Length2, m);
	}
	
	for(int i=0; i<n; i++)
		hv[i] = hv[i]/m/w*sphere;
		
	return hv;
}

double *Ihk_Polar(int popsize, int dim, int sample, int param_k, double **points, double *reference)
{
	int m = dim, n = popsize, w = sample;
	double *hv = new double [n];
	for(int i=0; i<n; i++)
		hv[i] = 0;
	double sum, v;
	
	double *jacobians = new double[w];
	double **weights = new double*[w];
	for(int i=0; i<w; i++)
	{
		weights[i] = new double[m];
	}
	ConstructLattice(m, w, weights, jacobians);
		
	double *alpha = new double[param_k];
	for(int i=0; i<param_k; i++)
	{
		alpha[i] = 1./(i+1);
		for(int j=1; j<=i; j++)
		{
			alpha[i] *= (double)(param_k - j)/(double)(n - j);
		}
	}		
	double *Length = new double[n+1];
	int *Index = new int[n+1];
	Length[n] = 0.;
	Index[n] = n;
	
	for(int i=0; i<w; i++)
	{
		for(int j=0; j<n; j++)
		{
			Length[j] = 1e30;	
			Index[j] = j;
			for(int k=0; k<m; k++)
			{
				v = -weights[i][k]*(points[j][k] - reference[k]);
				if(v<Length[j])
					Length[j] = v;
			}
			Length[j] = pow(Length[j], m) * jacobians[i];
		}
		Index_Sort(Length, Index, n);
		sum = 0.;
		for(int j=param_k-1; j>=0; j--)
		{
			sum += (Length[Index[j]] - Length[Index[j+1]]) * alpha[j];
			hv[Index[j]] = hv[Index[j]] + sum;
		}
	}	
	
	for(int i=0; i<n; i++)
		hv[i] = hv[i]/m/w*pow(PI/2, m-1);
	
	for(int i=0; i<w; i++)
	{
		delete[] weights[i];
	}
	delete[] weights;
	delete[] jacobians;
	delete[] alpha;
	delete[] Length;
	delete[] Index;
	
	return hv;
}

double *Ihk_Direction(int popsize, int dim, int sample, int param_k, double **points, double *reference, double **samples, double sphere)
{
	int m = dim, n = popsize, w = sample;
	double *hv = new double [n];
	for(int i=0; i<n; i++)
		hv[i] = 0;
	double sum, v;
	
	double *alpha = new double[param_k];
	for(int i=0; i<param_k; i++)
	{
		alpha[i] = 1./(i+1);
		for(int j=1; j<=i; j++)
		{
			alpha[i] *= (double)(param_k - j)/(double)(n - j);
		}
	}	
	double *Length = new double[n+1];
	int *Index = new int[n+1];
	Length[n] = 0.;
	Index[n] = n;
	
	for(int i=0; i<w; i++)
	{
		for(int j=0; j<n; j++)
		{	
			Length[j] = 1e30;	
			Index[j] = j;
			for(int k=0; k<m; k++)
			{
				v = -samples[i][k]*(points[j][k] - reference[k]);
				if(v<Length[j])
					Length[j] = v;
			}			
			Length[j] = pow(Length[j], m);
		}
		Index_Sort(Length, Index, n);
		sum = 0.;
		for(int j=param_k-1; j>=0; j--)
		{
			sum += (Length[Index[j]] - Length[Index[j+1]]) * alpha[j];
			hv[Index[j]] = hv[Index[j]] + sum;
		}
	}
	
	for(int i=0; i<n; i++)
		hv[i] = hv[i]/m/w*sphere;
	
	delete[] alpha;
	delete[] Length;
	delete[] Index;
	
	return hv;
}
